{"0": {
    "doc": "12/12/2020",
    "title": "Main Task",
    "content": "1. Writing Tutorial . Task Detail . | Github Page for Migration Project has been initiated. | . [Note] . ",
    "url": "http://localhost:4000/pages/user_guides/journals/1_201212.html#main-task",
    "relUrl": "/pages/user_guides/journals/1_201212.html#main-task"
  },"1": {
    "doc": "12/12/2020",
    "title": "12/12/2020",
    "content": "Today’s Date . Dec-12-2020 . ",
    "url": "http://localhost:4000/pages/user_guides/journals/1_201212.html",
    "relUrl": "/pages/user_guides/journals/1_201212.html"
  },"2": {
    "doc": "12/15/2020",
    "title": "Main Task",
    "content": "1. Optimizing Concentration.py code . Task Detail . | ODE solving part has been removed to make the calculation faster. | Can we just simply use the decay function for the activity? | This solved ODE in the calculation is function of time and local concentration. | That being said, the activation is only one direction. Always being activated and more activated. | . | stateVariable: How the coefficient is being determined based on the degree of local concentration will cause the problem in future for sure. | . def calcStateVariable(numberOfCells, time, ConcbyCell, stateVariable): #t = scipy.linspace(timeb,time,repeat) newstateVar = [] stateDepFactor = [] for n in np.arange(numberOfCells): # This is exponential function that is fitted to the exponential function if ConcbyCell[n] &gt; 1: coefficient = (1-1/ConcbyCell[n]) elif ConcbyCell[n] &gt; 0.9 - 1e-14 and ConcbyCell[n] &lt; 1 + 1e-14: coefficient = 0.5 elif ConcbyCell[n] &gt; 0.8 - 1e-14 and ConcbyCell[n] &lt; 0.9 + 1e-14: coefficient = 0.45 elif ConcbyCell[n] &gt; 0.7 - 1e-14 and ConcbyCell[n] &lt; 0.8 + 1e-14: coefficient = 0.4 elif ConcbyCell[n] &gt; 0.5 - 1e-14 and ConcbyCell[n] &lt; 0.7 + 1e-14: coefficient = 0.35 elif ConcbyCell[n] &gt; 0.2 - 1e-14 and ConcbyCell[n] &lt; 0.5 + 1e-14: coefficient = 0.3 else: coefficient = ConcbyCell[n] Var = coefficient*np.exp(-0.001*time-0.001*ConcbyCell[n]*time) + 0.001/(0.001 + 0.001*ConcbyCell[n]) #print(ConcbyCell[n]) newstateVar.append(Var) state = 1/(1+(0.2/Var)**5) stateDepFactor.append(state) return newstateVar, stateDepFactor . [Note] . ",
    "url": "http://localhost:4000/pages/user_guides/journals/2_201215.html#main-task",
    "relUrl": "/pages/user_guides/journals/2_201215.html#main-task"
  },"3": {
    "doc": "12/15/2020",
    "title": "12/15/2020",
    "content": "Today’s Date . Dec-15-2020 . ",
    "url": "http://localhost:4000/pages/user_guides/journals/2_201215.html",
    "relUrl": "/pages/user_guides/journals/2_201215.html"
  },"4": {
    "doc": "12/16/2020",
    "title": "Main Task",
    "content": "1. Optimizing Concentration.py or Calculation.py script . Task Detail . | Switiching distance calculation with numpy.linalg.norm(Vector) . | There are not so much to do… | . | . [Note] . ",
    "url": "http://localhost:4000/pages/user_guides/journals/3_201216.html#main-task",
    "relUrl": "/pages/user_guides/journals/3_201216.html#main-task"
  },"5": {
    "doc": "12/16/2020",
    "title": "12/16/2020",
    "content": "Today’s Date . Dec-16-2020 . ",
    "url": "http://localhost:4000/pages/user_guides/journals/3_201216.html",
    "relUrl": "/pages/user_guides/journals/3_201216.html"
  },"6": {
    "doc": "calculator.py File",
    "title": "calculator.py File",
    "content": "######################################################## #### Sub functions that need for FeedInForce plugin #### #### Writtne by Ben chun ############################### ######################################################## from simtk.unit import * from simtk.openmm import * from simtk.openmm.app import * from sys import stdout import numpy as np from FeedInplugin import FeedInForce from random import seed from random import randint import concentration as conc import random import scipy from scipy.optimize import curve_fit from scipy.integrate import odeint import yaml . ########################################################################### ### PDB Generator ### ########################################################################### def PDBgenNoPBC(PDBfileName, NoCell1, NoCell2, restingRatio1, restingRatio2): ''' [Note]: 11/06/2020 by Ben In this function, having all resting cells or activated cells will not cause any error. [Parameter Description] PDBfileName: pdb file name NoCell1: a total number of cells in the 1st half of box NoCell2: a total number of cells in the 2nd half of box restingRatio1: the proportion of resting cells in the 1st half of box restingRatio2: the proportion of resting cells in the 2nd half of box ''' # --- Writing pdb file initiated --- structure = open(PDBfileName+\".pdb\",\"w\") structure.write(\"MODEL 1 \\n\") ''' [------First half of box-------] ''' xo1 = np.zeros(NoCell1) yo1 = np.zeros(NoCell1) # although the simulation is in 2D box, it is required to register this in PDB file zo1 = np.zeros(NoCell1) # determining a total number of resting cells from the overall population ## the rest of cells are activated cells restingCell1 = int(NoCell1*restingRatio1) for n in np.arange(NoCell1): xo1[n] = randint(0,9) yo1[n] = randint(0,9) zo1[n] = randint(0,9) for i in np.arange(NoCell1): x = format(xo1[i],'.3f') y = format(yo1[i],'.3f') z = format(zo1[i],'.3f') # Registering resting and activated cells with name ID if i &lt;= restingCell1: name = 'RM' elif i &gt; restingCell1: name = 'AM' if i &lt; 9: structure.write(\"ATOM \"+str(i+1)+\" \"+name+\" \"+name+\" \"+str(i+1)+\" \"+str(x)+\" \"+str(y)+\" \"+str(z)+\" 1.00 0.00 \\n\") elif i &gt;= 9 and i &lt; 99: structure.write(\"ATOM \"+str(i+1)+\" \"+name+\" \"+name+\" \"+str(i+1)+\" \"+str(x)+\" \"+str(y)+\" \"+str(z)+\" 1.00 0.00 \\n\") elif i &gt;= 99 and i &lt; 999: structure.write(\"ATOM \"+str(i+1)+\" \"+name+\" \"+name+\" \"+str(i+1)+\" \"+str(x)+\" \"+str(y)+\" \"+str(z)+\" 1.00 0.00 \\n\") elif i &gt;= 999: structure.write(\"ATOM \"+str(i+1)+\" \"+name+\" \"+name+\" \"+str(i+1)+\" \"+str(x)+\" \"+str(y)+\" \"+str(z)+\" 1.00 0.00 \\n\") ''' [------Second half of box-------] ''' xo2 = np.zeros(NoCell2) yo2 = np.zeros(NoCell2) # although the simulation is in 2D box, it is required to register this in PDB file zo2 = np.zeros(NoCell2) # determining a total number of resting cells from the overall population ## the rest of cells are activated cells restingCell2 = int(NoCell2*restingRatio2) for n in np.arange(NoCell2): xo2[n] = randint(0,9) yo2[n] = randint(0,9) zo2[n] = randint(0,9) for i in np.arange(NoCell2): x = format(xo2[i],'.3f') y = format(yo2[i],'.3f') z = format(zo2[i],'.3f') # Registering resting and activated cells with name ID if i &lt;= restingCell2: name = 'RM' elif i &gt; restingCell2: name = 'AM' num = i + NoCell1 if num &lt; 9: structure.write(\"ATOM \"+str(num+1)+\" \"+name+\" \"+name+\" \"+str(num+1)+\" \"+str(x)+\" \"+str(y)+\" \"+str(z)+\" 1.00 0.00 \\n\") elif num &gt;= 9 and num &lt; 99: structure.write(\"ATOM \"+str(num+1)+\" \"+name+\" \"+name+\" \"+str(num+1)+\" \"+str(x)+\" \"+str(y)+\" \"+str(z)+\" 1.00 0.00 \\n\") elif num &gt;= 99 and num &lt; 999: structure.write(\"ATOM \"+str(num+1)+\" \"+name+\" \"+name+\" \"+str(num+1)+\" \"+str(x)+\" \"+str(y)+\" \"+str(z)+\" 1.00 0.00 \\n\") elif num &gt;= 999: structure.write(\"ATOM \"+str(num+1)+\" \"+name+\" \"+name+\" \"+str(num+1)+\" \"+str(x)+\" \"+str(y)+\" \"+str(z)+\" 1.00 0.00 \\n\") structure.write(\"ENDMDL\") structure.close return . ####################################################################################### ### Cell/Particle Distributor ### ####################################################################################### def genCellCoord3D(NoCell1, NoCell2, Rlim, CentoR, lowx, highx, lowy, highy, restingRatio1, restingRatio2, restMig, actMig, restAuto, actAuto): ''' [Parameter Description] NoCell1: a total number of cells in the 1st half of box NoCell2: a total number of cells in the 2nd half of box restingRatio1: the proportion of resting cells in the 1st half of box restingRatio2: the proportion of resting cells in the 2nd half of box Rlim: the minimum distance among cells CentoR: this will determine the size of 1st section of simulation box in x axis lowx: low end of simulation box in x axis highx: high end of simulation box in x axis lowy: low end of simulation box in y axis highy: high end of simulation box in y axis restMig: the degree of migratory response of resting cells actMig: the degree of migratory response of activated cells restAuto: the degree of autocrinic release of resting cells actAuto: the degree of autocrinic release of activated cells ''' coord=[] marker=[] total_num_cells = NoCell1 + NoCell2 autocrine_factor = np.zeros(total_num_cells) migration_factor = np.zeros(total_num_cells) coordtoYaml = {} minDist = Rlim bumper = 10 # this will prevent the placement beyond the actual dimension you assinged ## First box ## ### Configuring dimension where particles are placed # --- X axis --- if CentoR &gt; 0: if CentoR &gt; highx: print(\"The length of 1st half box should be smaller than the total length of simulation box\") print(\"[CentoR &lt; highx], Recommended to be less than half of a total length of simulation box\") sys.exit(0) elif CentoR &lt; highx and CentoR &gt; bumper: maxX1 = CentoR - bumper # in angstrom elif CentoR &lt; bumper: print(\"CentoR must be bigger than the bumper size (=10)\") sys.exit(0) elif CentoR == 0: CentoR = highx/3 maxX1 = CentoR-bumper minX1 = lowx + bumper # in angstrom # --- Y axis --- maxY1 = highy - bumper minY1 = lowy + bumper numP1 = 0 maxP1 = NoCell1 maxRestingP1 = int(NoCell1*restingRatio1) maxIter1 = 20000*maxP1 loopcounter1 = 1 xo = np.zeros(NoCell1) yo = np.zeros(NoCell1) #print(maxP1) while numP1 &lt; maxP1 and loopcounter1 &lt; maxIter1: xpossible = randint(minX1,maxX1) ypossible = randint(minY1,maxY1) if numP1 == 0: xo[numP1] = xpossible yo[numP1] = ypossible # -- marking state of cell -- # marker.append('resting') migration_factor[numP1] = restMig autocrine_factor[numP1] = restAuto # --------------------------- # coord.append([xpossible,ypossible,0]) coordtoYaml[str(numP1)] = [xpossible/10,ypossible/10,0] numP1 = numP1 + 1 continue distance1 = np.sqrt((xo-xpossible)**2 + (yo-ypossible)**2) if min(distance1) &gt;= minDist: xo[numP1] = xpossible yo[numP1] = ypossible coord.append([xpossible,ypossible,0]) coordtoYaml[str(numP1)] = [xpossible/10,ypossible/10,0] # -- marking state of cell -- # if numP1 &lt;= maxRestingP1: marker.append('resting') migration_factor[numP1] = restMig autocrine_factor[numP1] = restAuto elif numP1 &gt; maxRestingP1: marker.append('activated') migration_factor[numP1] = actMig autocrine_factor[numP1] = actAuto # --------------------------- # numP1 = numP1 + 1 loopcounter1 = loopcounter1 + 1 #print(numP1) ## Second box ## ### Configuring dimension where particles are placed # --- X axis --- maxX2 = CentoR*2 - bumper # in angstrom minX2 = CentoR + bumper # in angstrom # --- Y axis --- maxY2 = highy - bumper minY2 = lowy + bumper numP2 = 0 maxP2 = NoCell2 maxRestingP2 = int(NoCell2*restingRatio2) maxIter2 = 20000*NoCell2 loopcounter2 = 1 xo2 = np.zeros(NoCell2) yo2 = np.zeros(NoCell2) #print(maxP2) while numP2 &lt; maxP2 and loopcounter2 &lt; maxIter2: xpossible = randint(minX2,maxX2) ypossible = randint(minY2,maxY2) if numP2 == 0: xo2[numP2] = xpossible yo2[numP2] = ypossible # -- marking state of cell -- # marker.append('resting') migration_factor[numP1+numP2] = restMig autocrine_factor[numP1+numP2] = restAuto # --------------------------- # coord.append([xpossible,ypossible,0]) coordtoYaml[str(numP1+numP2)] = [xpossible/10,ypossible/10,0] numP2 = numP2 + 1 continue distance1 = np.sqrt((xo2-xpossible)**2 + (yo2-ypossible)**2) if min(distance1) &gt;= minDist: xo2[numP2] = xpossible yo2[numP2] = ypossible coord.append([xpossible,ypossible,0]) coordtoYaml[str(numP1+numP2)] = [xpossible/10,ypossible/10,0] # -- marking state of cell -- # if numP2 &lt;= maxRestingP2: marker.append('resting') migration_factor[numP1+numP2] = restMig autocrine_factor[numP1+numP2] = restAuto elif numP2 &gt; maxRestingP2: marker.append('activated') migration_factor[numP1+numP2] = actMig autocrine_factor[numP1+numP2] = actAuto # --------------------------- # numP2 = numP2 + 1 loopcounter2 = loopcounter2 + 1 #print(numP2) #print(np.shape(coord)) #coord = coord/10 for i in np.arange(NoCell1+NoCell2): for j in np.arange(3): coord[i][j] = coord[i][j]/10 ## &lt;--- angstrom to nano meter conversion ## Store coordinates in yaml file with open('dummy.yml','w') as file: document = yaml.dump(coord,file) return coord, marker, migration_factor, autocrine_factor . ############################################################################################### ### Written by Yehven and implemented by Ben ### ############################################################################################### def calcForce(positions, numberOfCells, Origin, SourceOfOrigin, oriConc, cellConc, Diff, t, kd, highBC, DisplacementScaleByConc, searchingRange, marker, auto_factor, state, ConcByCell): ''' [Parameter Description] positions: position of cells from pdb file numberOfCells: total number of cells (num of cells in 1st half + num of cells in 2nd half) Origin: the origin of chemoattractant source SourceOfOrigin: None = One end of simulation box in x axis, Center = the center of simulation box oriConc: the max concentration released from the source of chemoattractant cellConc: the max concentration released by cells (determining the degree of intercellular communication) Diff: the diffusion rate of chemoattractant t: time kd: constant associated with Hills coefficient for autocrinic release highBC: [max X, max Y, max Z] DisplacementScaleByConc: Displacement Scale searchingRange: searching range around the cell marker: a list of marker for resting and activated cells auto_factor: a list of autocrinic factors based on the state of cells state: the characteristics of diffusion of chemoattractant: steady, error, or linear ConcByCell: the concentration accumulated by the attractant released from each individual cell ''' # Do some magic here that will return substrate field-related force acting on each particle n = 0 dummy_coord = np.zeros([3,numberOfCells]) #ConcByCell = np.zeros(numberOfCells) + 1e-14 for i in enumerate(positions): dummy_coord[0][n] = i[1][0].value_in_unit(nanometers) dummy_coord[1][n] = i[1][1].value_in_unit(nanometers) dummy_coord[2][n] = i[1][2].value_in_unit(nanometers)*0 n += 1 recordedPositions = dummy_coord DistCelltoOrigin = conc.DistCelltoOrigin(recordedPositions, Origin, SourceOfOrigin, state) DistCelltoCell = conc.DistCelltoCell(recordedPositions) ConcByOrigin = conc.ConcByOrigin(DistCelltoOrigin, t, Diff, oriConc, state, Origin) ConcbyCell, HC = conc.ConcByCell(ConcByOrigin, ConcByCell, DistCelltoCell, t, Diff, kd, auto_factor, cellConc) fvX, fvY, fvZ = conc.forceGen(ConcbyCell, Origin, SourceOfOrigin, recordedPositions, t, Diff, HC, searchingRange, highBC, DisplacementScaleByConc, cellConc, oriConc, state) return fvX, fvY, fvZ, ConcbyCell . ############################################################################################### ### Written by Ben and implemented by Ben ### ############################################################################################### def stateFunc(y,t,c): ## Rate of state transition kf = 0.1 kb = 0.01 dydt = kf*c*(1-y) - kb*y return dydt def calcStateVariable(numberOfCells, repeat, timeb, time, ConcbyCell, stateVariable): t = scipy.linspace(timeb,time,repeat) newstateVar = [] stateDepFactor = [] for n in np.arange(numberOfCells): stateVar = odeint(stateFunc,stateVariable[n],t,args=(ConcbyCell[n],)) dummy1 = np.float(stateVar[-1]) newstateVar.append(dummy1) dummy2 = 1/(1+dummy1/0.50) stateDepFactor.append(dummy2) return newstateVar, stateDepFactor def calcForceModified(numberOfCells, fvX, fvY, fvZ, stateDepFactor, mig_factor): # This is where I can make an adjustment for resting and activated cells forces = [] for i in range(numberOfCells): force_on_particle = [fvX[i]*mig_factor[i]*stateDepFactor[i], fvY[i]*mig_factor[i]*stateDepFactor[i], fvZ[i]*mig_factor[i]*stateDepFactor[i]*0] forces.append(force_on_particle) return forces . ########################################################################### ### Test RUN - OpenMM ### ########################################################################### def testRunner(filename): pdb = PDBFile(filename+'.pdb') forcefield = ForceField('/home/bending456/Ben-Code/Modeling-Codes/Codes/OpenMM_Tutorial/Particle_in_box/Particle_Ben.xml') system = forcefield.createSystem(pdb.topology, nonbondedMethod=PME, nonbondedCutoff=1*nanometer, constraints=HBonds) integrator = LangevinIntegrator(300*kelvin, 1/picosecond, 0.002*picoseconds) simulation = Simulation(pdb.topology, system, integrator) simulation.context.setPositions(pdb.positions) simulation.minimizeEnergy() simulation.reporters.append(PDBReporter('output.pdb', 10)) simulation.reporters.append(StateDataReporter(stdout, 10, step=True, potentialEnergy=True, temperature=True)) simulation.step(10) return . ",
    "url": "http://localhost:4000/pages/user_guides/PythonScript/calculator.html",
    "relUrl": "/pages/user_guides/PythonScript/calculator.html"
  },"7": {
    "doc": "concentration.py File",
    "title": "Required python package",
    "content": "####################################################### ## Concentration Gradient Calculator ## ## Written By Ben Chun ## ####################################################### import numpy as np from random import seed from random import randint from scipy import special . Error function based diffusion . | In this simulation there are three modes of calculation scheme for diffusion of chemoattractant substance in the background. One of three is error function based on the steady state diffusion in 1D. ############################ #### Diffusion function #### def func(r,t,D): rt = r/(2*np.sqrt(D*t)) erf = special.erfc(rt) return erf ############################ . | . Calculating distance from the source of chemoattractant source . | There are two major types of calculations based on the location of substance sources. | Center: the source of chemoattractant is located in the center of simulation box. Therefore, the calculation of distance between the position of cell and the location of the source is based on the radial fashion. | None: It is basically slab, the source of which is located at the end of x axis (right side). | . | . ############################################################################################################################# ### Distance of Cell from the location of Damaged Cell ### This will be used to calculate the released substance concentration from the damaged cell at the given cell location def DistCelltoOrigin(CellCoord, Origin, SourceOfOrigin, state): ''' [Parameter descriptions] CellCoord: the coordinates of particles Origin: the origin of chemoattractant source SourceOfOrigin: None = One end of simulation box in x axis, Center = the center of simulation box state: the characteristics of diffusion of chemoattractant: steady, error, or linear ''' NoOfCell = np.shape(CellCoord)[1] CelltoOrigin_r = np.zeros(NoOfCell) xOrigin, yOrigin, zOrigin = Origin xyOrigin = np.array([xOrigin,yOrigin]) for nthCell in np.arange(NoOfCell): # Differentiate the scheme of distasnce calculation between cells and the source of external chemoattractant source if SourceOfOrigin is None: xCell = CellCoord[0][nthCell] dist = abs(xCell-xOrigin) elif SourceOfOrigin == 'Center': xyCell = np.array([CellCoord[0][nthCell],CellCoord[1][nthCell]]) dist = np.linalg.norm(xyCell-xyOrigin) CelltoOrigin_r[nthCell] = dist.copy() return CelltoOrigin_r . Calculating distance from cell to cell . | The gradient of substances in this calculation is based on the error function. Its source releases a certain amount, but the cells contribute the same chemical to the gradient formation (ex. ATP-mediated ATP release.) | . #################################################################################################################### ### Distance among cells ### This will be used to calculate the released substance concentration from individual cell at the given cell location def DistCelltoCell(CellCoord): NoOfCell = np.shape(CellCoord)[1] CelltoCell_r = {} xcoord = CellCoord[0] ycoord = CellCoord[1] for nthCell in np.arange(NoOfCell): xncoord = CellCoord[0][nthCell] yncoord = CellCoord[1][nthCell] dist = np.sqrt((xcoord-xncoord)**2+(ycoord-yncoord)**2) CelltoCell_r[nthCell] = dist.copy() return CelltoCell_r # this is in dictionary form but it doesn't have to be . Concentration of substance as a function of cell position with respect to the source of substance. | There are three states: linear, steady, and error. | Linear: a simple linear function (y=ax+b) governs the concentration gradient’s estimation from the source of substances to the cell location. | Steady: the media is fully saturated with substances. | Error: an error function is used to estimate the concentration gradient from the source of substances to the cell location. | . | . ####################################################################### ### Concentration of Chemoattractant released from the external source def ConcByOrigin(CelltoOrigin_r, t, D, oriConc, state, Origin): ''' [Parameter descriptions] CelltoOrigin_r: the distance of individual cell from the exteranl source t: time D: Diffusion rate of chemoattractant oriConc: the max concentration of external chemoattractant constant state: the characteristic state of diffusion of chemoattractant ''' xOri, yOri, zOri = Origin if state == 'linear': Conc = (1-CelltoOrigin_r/xOri)*oriConc elif state == 'steady': Conc = np.ones(len(CelltoOrigin_r))*oriConc elif state == 'error': Conc = func(CelltoOrigin_r,t,D)*oriConc return Conc . Concentration of substance as a function of cell position with respect to other cells. | Their input, which is the distance of one cell from others, is a list of distance with respect to other cell positions. | The release of a substance from each cell is a function of the concentration of substance present at the cell’s position. The local concentration is applied to the Hill’s equation that generates the coefficient and controls the degree of release. | [Things to remember] CelltoCell_r[nthCell] = [ 0 1 1 1 1 1 1 1 2 3 4 5 6 7 8 9 ... nth_distance ] . | This being said, the data generated by usind this distance will contain the series of substance concentration at each individual location by the selected cell. | . ########################################################################################## ### Concentration of Chemoattractant reased from the indivudal cells def ConcByCell(ConcByOrigin, ConcByCell, CelltoCell_r, t, D, kd, auto_factor, cellConc): ''' [Parameter description] ConcByOrigin: the concentration released by the external source ConcByCell: the concentration released by the cell CelltoCell_r: the distance among cells dictionary form t: time D: diffusion rate kd: constant associated with Hills coefficient for autocrinic release auto_factor: a list of autocrinic factors based on the state of cells cellConc: the max concentration released by cells (determining the degree of intercellular communication) ''' NoOfCell = len(ConcByOrigin) ConcByCell = ConcByOrigin + ConcByCell HillsCoefficient = 1/(1+((kd*auto_factor)/ConcByCell)) ## So far, there is no degree of coopertivity &lt;---- this is where I can make adjustment for resting and activated cells data = np.zeros(NoOfCell) for nthCell in np.arange(NoOfCell): dist = CelltoCell_r[nthCell] ## array with length of NoOfCell dummydata = HillsCoefficient[nthCell]*func(dist,t,D)*cellConc ## array (from specific cell to all cells) data = data + dummydata ConcByCell = ConcByCell + data HillsCoefficient = 1/(1+((kd*auto_factor)/ConcByCell)) return ConcByCell, HillsCoefficient . Force Generator based on the concentration gradient . | This specific code will generate vector indicating the degree of force generated by the concentration gradient. | Direction of vector will be against graident, meaning that from low to high concentration. | *Warning: we have not determined the degree of migration based on the concentration gradient. Therefore, the unit is arbitrary. | . | Searching/estimating the concentration gradient . | Select a cell | Generate coordinates for cell’s surroundings . | x11: x coordinate for the selected cell | x01: x11 - searching range | x21: x11 + searching range | vice versa for y coordinate. | A total of 5 sets of (x,y) are generated from this process | . | Calculate the distance of each coordinate from the preceeding process to the location of the chemoattractant’s source. | Calculate the distance of each coordinate from the surroundings to other cells | Combine the concentration of substance released by other cells and the concentration of substance released from the source. | Calculate the vector in x and y direction based on the concentration differences. | Multiply each element of force by random probability with slighly bias medium . | The center of normal distribution is 0.25 | If there is no gradient then there will be no force (duh… obviously) | . | To exaggerate the motion of cell with respect to the local concentration, we introduce another random factor obtained another normal distribution whose center is 0.0. | In Brownian motion, the temperature should be adjust to control the motion of particle. In this case, due to the technical difficulty, it is not possible to locally reassign the temperature of each individual particle or cell. | Therefore, we are simply applying a new set of force. | . | . | . ####################################################################################################### ### Generate the force of migration based on the gradient of chemoattractant along wiht Brownian Motion def forceGen(ConcByCell, Origin, SourceOfOrigin, CellCoord, t, D, HillsCoefficient, searchingRange, highBC, DisplacementScaleByConc, cellConc, oriConc, state): ''' [Parameter description] ConcByCell: the concentration released by the cell Origin: the origin of chemoattractant source SourceOfOrigin: None = One end of simulation box in x axis, Center = the center of simulation box CellCoord: position of cells from pdb file t: time D: diffusion rate HillsCoefficient: Hills coefficient for autocrinic release searchingRange: searching range around the cell highBC: [max X, max Y, max Z] DisplacementScaleByConc: the degree of displacement cellConc: the max concentration of chemoattractant released from the cell via autocrine oriConc: the max concentration of chemoattractant released from the external source state: the characteristics of diffusion of chemoattractant: steady, error, or linear ''' NoOfCell = np.shape(CellCoord)[1] highBCx, highBCy, highBCz = highBC ## x1,y1,z1 denotes the x,y,z coordinate of cell location FVectorX = np.zeros(NoOfCell) FVectorY = np.zeros(NoOfCell) FVectorZ = np.zeros(NoOfCell) # x xtest = np.array([CellCoord[0]-searchingRange,CellCoord[0],CellCoord[0]+searchingRange]) # y ytest = np.array([CellCoord[1]-searchingRange,CellCoord[1],CellCoord[1]+searchingRange]) # the distance from the one end where ATP is being released if SourceOfOrigin is None: rSource = np.array([abs(Origin[0]-xtest[0]),abs(Origin[0]-xtest[1]),abs(Origin[0]-xtest[2])]) Conc_Origin = ConcByOrigin(rSource,t,D,oriConc,state,Origin) COarray = np.array([Conc_Origin[0],Conc_Origin[2],Conc_Origin[1],Conc_Origin[1],Conc_Origin[1]]) elif SourceOfOrigin == 'Center': xSource = np.array([(Origin[0]-x0),(Origin[0]-x1),(Origin[0]-x2)])**2 ySource = np.array([(Origin[1]-y0),(Origin[1]-y1),(Origin[1]-y2)])**2 rSource = np.sqrt(np.array([xSource[0]+ySource[1],xSource[2]+ySource[1],xSource[1]+ySource[0],xSource[0]+ySource[2],xSource[1]+ySource[1]])) COarray = ConcByOrigin(rSource,t,D,oriConc,state,Origin) xcell = CellCoord[0] ycell = CellCoord[1] xprob = np.random.normal(0.25,1,NoOfCell) yprob = np.random.normal(0.25,1,NoOfCell) xrand = np.random.normal(0,0.5,NoOfCell) yrand = np.random.normal(0,0.5,NoOfCell) for nthCell in np.arange(NoOfCell): rfromCells01 = np.sqrt((xcell-(xcell[nthCell]-searchingRange))**2 + (ycell-ycell[nthCell])**2) rfromCells21 = np.sqrt((xcell-(xcell[nthCell]+searchingRange))**2 + (ycell-ycell[nthCell])**2) rfromCells10 = np.sqrt((xcell-xcell[nthCell])**2 + (ycell-(ycell[nthCell]-searchingRange))**2) rfromCells12 = np.sqrt((xcell-xcell[nthCell])**2 + (ycell-(ycell[nthCell]+searchingRange))**2) rfromCells11 = np.sqrt((xcell-xcell[nthCell])**2 + (ycell-ycell[nthCell])**2) CCarray = np.array([sum(HillsCoefficient*func(rfromCells01,t,D)*cellConc), sum(HillsCoefficient*func(rfromCells21,t,D)*cellConc), sum(HillsCoefficient*func(rfromCells10,t,D)*cellConc), sum(HillsCoefficient*func(rfromCells12,t,D)*cellConc), sum(HillsCoefficient*func(rfromCells11,t,D)*cellConc)]) ConcTotal = np.array([COarray[0][nthCell],COarray[1][nthCell],COarray[2][nthCell],COarray[3][nthCell],COarray[4][nthCell]]) + CCarray ## Calculating the concentration gradient dx = (ConcTotal[1] - ConcTotal[0])/2 dy = (ConcTotal[3] - ConcTotal[2])/2 dz = 0 # Determining in X direction force xp = xprob[nthCell] DispX = dx*xp # Determining in Y direction force yp = yprob[nthCell] DispY = dy*yp FVectorX[nthCell] = DisplacementScaleByConc*(DispX + xrand[nthCell]*0.015)*ConcTotal[4] FVectorY[nthCell] = DisplacementScaleByConc*(DispY + yrand[nthCell]*0.015)*ConcTotal[4] FVectorZ[nthCell] = 0 return FVectorX, FVectorY, FVectorZ . ",
    "url": "http://localhost:4000/pages/user_guides/PythonScript/concentration.html#required-python-package",
    "relUrl": "/pages/user_guides/PythonScript/concentration.html#required-python-package"
  },"8": {
    "doc": "concentration.py File",
    "title": "concentration.py File",
    "content": " ",
    "url": "http://localhost:4000/pages/user_guides/PythonScript/concentration.html",
    "relUrl": "/pages/user_guides/PythonScript/concentration.html"
  },"9": {
    "doc": "Introduction",
    "title": "Introduction",
    "content": "This tutorial will guide users from the installation of OpenMM package and the customized pacakge written by Yevhen, called FeedInForce (Special Thank To Yevhen!!) to the OpenMM based cell migration. ",
    "url": "http://localhost:4000/",
    "relUrl": "/"
  },"10": {
    "doc": "Introduction",
    "title": "What are we trying to simulate via this script?",
    "content": "About this project . We are specifically trying to simulate the migration of microglial cells as the chemoattractant is present their surroundings. Therefore, this calculation contains: . | Estimation of chemoattractant diffusion | Simulation of migration based on the gradient of chemoattractant concentration. | . ",
    "url": "http://localhost:4000/#what-are-we-trying-to-simulate-via-this-script",
    "relUrl": "/#what-are-we-trying-to-simulate-via-this-script"
  },"11": {
    "doc": "Installation of OpenMM and FeedInForce",
    "title": "Before you start…",
    "content": "This specific tutorial is meant to instructe those who are familiar with Linux/Unix environment with Python background. Possibly more than my experience and skillset. 0. Install CUDA . Instruction Link . 1. Install OpenMM from source . Official Link . Download the package from Git Link . git clone https://github.com/openmm/openmm.git . 2. Install FeedInForce developed by Yehven . Download the package from Git Link . git clone https://github.com/YevChern/FeedInForce_openmm . go to the plugin directory . ccmake CMakeLists.txt cmake CMakeLists.txt . then edit your openMM directory section and cmake install prefix section with /path/to/OpenMM Also, make sure your python version. If python2 and 3 are installed in your system, then /usr/bin/python for python2 and /usr/bin/python3 for python3 . or . cmake CMakeLists.txt -DOPENMM_DIR='/path/to/OpenMM' -DCMAKE_INSTALL_PREFIX='/path/to/OpenMM' -DPYTHON_EXECUTABLE='/usr/bin/python' or '/usr/bin/python3' . execute make install by the following . make install . if you are using python installed over system . sudo make PythonInstall . if not . make PythonInstall . If you run into error by saying the following: . compilation terminated. error: command 'x86_64-linux-gnu-gcc' failed with exit status 1 python/CMakeFiles/PythonInstall.dir/build.make:66: recipe for target 'PythonInstall' failed make[3]: *** [PythonInstall] Error 1 CMakeFiles/Makefile2:348: recipe for target 'python/CMakeFiles/PythonInstall.dir/all' failed make[2]: *** [python/CMakeFiles/PythonInstall.dir/all] Error 2 CMakeFiles/Makefile2:355: recipe for target 'python/CMakeFiles/PythonInstall.dir/rule' failed make[1]: *** [python/CMakeFiles/PythonInstall.dir/rule] Error 2 Makefile:240: recipe for target 'PythonInstall' failed make: *** [PythonInstall] Error 2 . The best bet is something went wrong in your setup.py. In general, it should be automatically corrected after executing ccmake and cmake install. To fix this, go to FeedInForce_openmm/plugin/python and correct openmm_dir in setup.py as . openmm_dir = '/path/to/your/openmm' . 3. Running exmaples . Run example at FeedInForce_openmm/example . python run.py . or . python3 run.py . if you are running into error for libFeedInForce.so isn’t available . export LD_LIBRARY_PATH='$LD_LIBRARY_PATH:/path/to/OpenMM/lib:/path/to/OpenMM' . or . Add the following in .bashrc and source . export LD_LIBRARY_PATH=${LD_LIBRARY_PATH}:/path/to/OpenMM/lib:/path/to/OpenMM . Exit to terminal and . source .bashrc . ",
    "url": "http://localhost:4000/pages/user_guides/installation.html#before-you-start",
    "relUrl": "/pages/user_guides/installation.html#before-you-start"
  },"12": {
    "doc": "Installation of OpenMM and FeedInForce",
    "title": "Installation of OpenMM and FeedInForce",
    "content": " ",
    "url": "http://localhost:4000/pages/user_guides/installation.html",
    "relUrl": "/pages/user_guides/installation.html"
  },"13": {
    "doc": "Work Log",
    "title": "Instruction for Journal Writing",
    "content": "Templatge . --- title: Today's Date nav_order: check the file name parent: Work Log --- #### Today's Date Month-XX-XXXX -------------------------------------------------------------------------------- ## Main Task ### 1. What was the major task #1 #### Task Detail - here is what i did ### 2. What was the major task #2 #### Task Detail - here is what i did ---------------------------------------------------------- [Note] . ",
    "url": "http://localhost:4000/pages/user_guides/journal.html#instruction-for-journal-writing",
    "relUrl": "/pages/user_guides/journal.html#instruction-for-journal-writing"
  },"14": {
    "doc": "Work Log",
    "title": "Work Log",
    "content": "This is the author’s journal to keep tracking errors and trials to improve the code to assist users in some fashion. ",
    "url": "http://localhost:4000/pages/user_guides/journal.html",
    "relUrl": "/pages/user_guides/journal.html"
  },"15": {
    "doc": "operator.py File",
    "title": "operator.py File",
    "content": "import os import numpy as np import yaml import time as timer time = 10000 DispScale = 7500 #2500 highlim = 150 the_len_of_1st_box = 0 #highlim*3 repeat = 1 cellconc = 0.0 oriConc = 5.0 restingratio1 = 0.5 restingratio2 = [0.1]#,0.5,0.9] shape = 'slab' # slab - work with SourceOfOrigin = None or square - work with SourceOfOrigin = Center DiffState = 'error' # error (for error function), steady, or linear DiffRate = 5 density_list1 = [50] density_list2 = [50]#,50,100] no_of_series_sim = len(density_list1)*len(density_list2) start_whole = timer.time() print('|-----SIMULATION INITIATED-----|') count = 1 for i in np.arange(repeat): if i == 0: start_single = timer.time() for ratio2 in restingratio2: for nocell1 in density_list1: for nocell2 in density_list2: inputname = 'test'+str(count) outputname = 'test'+str(count) count += 1 os.system('python3 runner.py -t '+str(time)+ ' -highlimBoxlen '+str(highlim)+ ' -numOfCells1 '+str(nocell1)+ ' -numOfCells2 '+str(nocell2)+ ' -restingRatio1 '+str(restingratio1)+ ' -restingRatio2 '+str(ratio2)+ ' -CentoR '+str(the_len_of_1st_box)+ ' -DispScale '+str(DispScale)+ ' -name '+outputname+ ' -input '+inputname+ ' -cellConc '+str(cellconc)+ ' -oriConc '+str(oriConc)+ ' -shape '+shape+ ' -DiffState '+DiffState+ ' -Diff '+str(DiffRate)) if i == 0: currentg_single = timer.time() print('|-----Single Run Job Statistics-----|') print('|------ %s secs ------|' % (currentg_single-start_single)) print('|------ %s mins ------|' % ((currentg_single-start_single)/60)) print('|------ %s hrs ------|' % ((currentg_single-start_single)/3600)) print('|--------------------------------|') print('|-----Estimated Job Duration-----|') estimated_sec = (currentg_single-start_single+1*repeat)*repeat estimated_min = estimated_sec/60 estimated_hrs = estimated_min/60 print('|------ %s secs ------|' % (estimated_sec)) print('|------ %s mins ------|' % (estimated_min)) print('|------ %s hrs ------|' % (estimated_hrs)) else : current_single = timer.time() current_sec = current_single - start_single current_min = current_sec/60 current_hrs = current_min/60 print('|-----Simulation has been excuted since... -----|') print('|------'+str(current_sec)+' secs ago and possibly '+str(estimated_sec-current_sec)+' secs remaining ------|') print('|------'+str(current_min)+' mins ago and possibly '+str(estimated_min-current_min)+' mins remaining ------|') print('|------'+str(current_hrs)+' hrs ago and possibly '+str(estimated_hrs-current_hrs)+' hrs remaining ------|') print('|-----SIMULATION COMPLETED-----|') print('|------ %s secs ------|' % (timer.time()-start_whole)) print('|------ %s mins ------|' % ((timer.time()-start_whole)/60)) print('|------ %s hrs ------|' % ((timer.time()-start_whole)/3600)) . ",
    "url": "http://localhost:4000/pages/user_guides/PythonScript/operator.html",
    "relUrl": "/pages/user_guides/PythonScript/operator.html"
  },"16": {
    "doc": "What's in Python Files?",
    "title": "What's in Python Files?",
    "content": "This page will introduce the detail information of each python script that is stitched with child python script to enable the migration simulation. How to start OpenMM . ",
    "url": "http://localhost:4000/pages/user_guides/python.html",
    "relUrl": "/pages/user_guides/python.html"
  },"17": {
    "doc": "runner.py File",
    "title": "runner.py File",
    "content": "##################################################################################### # This is an example usage of the interface to feed forces into OpenMM with Python. # ##################################################################################### from simtk.unit import * from simtk.openmm import * from simtk.openmm.app import * from sys import stdout import numpy as np from FeedInplugin import FeedInForce from random import seed from random import randint import calculator as calc import time as timer import os import random here=os.path.dirname(os.path.abspath(__file__)) ''' [Note]: 11/06/2020 by Ben This simulation is designed for 2D space but it can be also implemented in 3D ''' ## This is where parameters are being stored def simulator(oriConc = 10, # the max concentration released from the source of chemoattractant cellConc = 1, # the max concentration released by cells (determining the degree of intercellular communication) Diff = 10, # the diffusion rate of chemoattractant kd = 10, # constant associated with Hills coefficient for autocrinic release DispScale = 100000, # Displacement Scale ... wrong name I guess searchingRange = 0.1, # searching range around the cell numOfCells1 = 50, # a total number of cells in the 1st section of simulation box numOfCells2 = 50, # a total number of cells in the 2nd section of simulation box CentoR = 0, # this will determine the size of 1st section of simulation box in x axis pdbFileName = 'temp', # generated PDB file name dcdfilename = 'test_output2', # generated DCD file name lowlimBoxlen =0, # in angstrom = 1/10 of nanometer (REMEMBER!!) ??? do I need this? highlimBoxlen =1000, # in angstrom = 1/10 of nanometer (REMEMBER!!) SourceOfOrigin = None, # None = One end of simulation box in x axis, Center = the center of simulation box simLength = 10000, # a total number of the simulation steps dumpSize = 100, # dump size in the dcd generation process restingRatio1 = 0.8, # the proportion of resting cells in the overall population of cells in the 1st section restingRatio2 = 0.8, # the proportion of resting cells in the overall population of cells in the 2nd section restMig = 0.5, # the degree of migratory response of resting cells actMig = 0.1, # the degree of migratory response of activated cells restAuto = 10, # the degree of autocrinic release of resting cells: the larger, the less insensitive actAuto = 0.1, # the degree of autocrinic release of activated cells shape = 'slab', # shape of simulation box: either slab or square DiffState = 'steady' # the characteristics of diffusion of chemoattractant: steady, error, or linear ): # This will generate the random structure that makes no sence but will be processed again ## Note: This will generate dummy pdb file that will pass the test run but it is irrelevant to the actual calculation. calc.PDBgenNoPBC(pdbFileName,numOfCells1,numOfCells2,restingRatio1,restingRatio2) pdb = PDBFile(pdbFileName+'.pdb') # Configure Dumping frequency dumpingstep = dumpSize dcdReporter = DCDReporter(dcdfilename+'.dcd', dumpingstep) # Simulation Box Dimension in angstrom if shape == 'slab': shape_factor = 3 elif shape == 'square': shape_factor = 1 ## Configure the coordinate of origin of external signal cascades if SourceOfOrigin is None: dummy = (np.int(highlimBoxlen*shape_factor))/(10) OriginOfExternalSignal = [dummy,0,0] # in nanometer elif SourceOfOrigin == 'Center': dummy = (np.int(highlimBoxlen))/(10) OriginOfExternalSignal = [dummy*shape_factor/2,dummy/2,0] # Defining the dimension of simulation box x = [lowlimBoxlen,highlimBoxlen*shape_factor] y = [lowlimBoxlen,highlimBoxlen] z = [0,0] highBC = np.array([x[1],y[1],z[1]]) # Configure Simulation Length Repeat = simLength stepFreq = 1 # Parameters determining the dynamics of cells MassOfCell = 100 RepulsiveScale = 0.1 # this can determine the distance among cells themselves ### Simulation parameters temperature = 295 #0.0 # K &lt;---- set to 0 to get rid of wiggling for now frictionCoeff = 1.0 # 1/ps step_size = 0.002 # ps ########################################################## ### OpenMM Simulation Control ### ########################################################## # Create an OpenMM System object system = System() # Create CustomNonbondedForce. We use it to implement repulsive potential between particles. # Only keep repulsive part of L-J potential nonbond = CustomNonbondedForce(\"(sigma/r)^12; sigma=0.5*(sigma1+sigma2)\") nonbond.addPerParticleParameter(\"sigma\") # Here we don't use cutoff for repulsive potential, but adding cutoff might speed things up a bit as interaction # strength decays very fast. nonbond.setNonbondedMethod(CustomNonbondedForce.NoCutoff) # Add force to the System system.addForce(nonbond) # FeedInForce is an OpenMM Force object that serves as the interface to feed forces into the simulation. It stores # additional forces that we want to introduce internally and has a method # .updateForceInContext(OpenMM::Context context, vector&lt; vector&lt;double&gt; &gt; in_forces). in_forces should be a vector of # 3d vectors - one 3d vector per particle and each 3d vector should contain X,Y,Z components of the force. # updateForceInContext() will copy forces from in_forces into internal variable that will keep them # until updateForceInContext() is called again. Every simulation step OpenMM will add forces stored in FeedInForce to # the simulation. You don't need to call updateForceInContext() every step if the forces didn't change - OpenMM will # use the forces from the last call of updateForceInContext(). in_force = FeedInForce() # Add in_force to the system system.addForce(in_force) num_particles = len(pdb.getPositions()) ### Make it 2D energy_expression = 'k * (z^2)' force = openmm.CustomExternalForce(energy_expression) force.addGlobalParameter('k', 999) for particle_index in range(num_particles): force.addParticle(particle_index, []) system.addForce(force) ## This will generate more reasonable structure but still needs to take number of particle from the arbitrary structure ## The reason I choose to do so is generating PDB file is little tricky due to its sensitivity to line arrangement min_dist_among_cells = 5 xlow_end = x[0] xhigh_end = x[1] ylow_end = y[0] yhigh_end = y[1] ''' [Outcomes of genCellCoord3D] initPosInNm: coordnates of cells in array format (num_particles by [x,y,z]) marker: a list of markers for resting and activated cells (length of num_particles) migration_factor: a list of constants for migration degree for resting and activated (length of num_particles) autocrine_factor: a list of constants for autocrinic degree for resting and activated (lengh of num_particles) ''' initPosInNm, marker, mig_factor, auto_factor = calc.genCellCoord3D(numOfCells1, numOfCells2, min_dist_among_cells, CentoR, xlow_end, xhigh_end, ylow_end, yhigh_end, restingRatio1, restingRatio2, restMig, actMig, restAuto, actAuto) for i in range(num_particles): # Populate the system with particles. # system.addParticle(mass in atomic mass units) system.addParticle(MassOfCell) # 100.0 is a particle mass # Add particles to CustomNonbondedForce. Here we define repulsion strength sigma for each particle. If particles # have different value of sigma, combination rule sigma=0.5*(sigma1+sigma2) will be applied as defined in # CustomNonbondedForce force expression. sigma = RepulsiveScale nonbond.addParticle([sigma]) # Create integrator integrator = BrownianIntegrator(temperature, frictionCoeff, step_size) # Create platform platform = Platform.getPlatformByName('CUDA') # Create simulation simulation = Simulation(pdb.topology, system, integrator, platform) print('Simulation is initiated') print('REMARK Using OpenMM platform %s' % simulation.context.getPlatform().getName()) # Set initial positions for the particles simulation.context.setPositions(initPosInNm) # Simulate # We can add dcd or other reporters to the simulation to get desired output with ## Note: Ben's version simulation.reporters.append(dcdReporter) time = 0.001 # &lt;----- can't start at 0; Otherwise, the calculation blows up ## Set the initial stateVariable: Starting from 0 for now. #odeiter = 5 stateVariable = np.ones([num_particles]) # storing initial position rest_cell_no = int(numOfCells1*restingRatio1)+int(numOfCells2*restingRatio2)+2 act_cell_no = num_particles - rest_cell_no resting_start = np.zeros([2,rest_cell_no]) activated_start = np.zeros([2,act_cell_no]) positions = simulation.context.getState(getPositions=True).getPositions() rest_cnt = 0 act_cnt = 0 cell_cnt = 0 for pos in enumerate(positions): if marker[cell_cnt] == 'resting' : resting_start[0][rest_cnt] = pos[1][0].value_in_unit(angstroms) resting_start[1][rest_cnt] = pos[1][1].value_in_unit(angstroms) rest_cnt += 1 elif marker[cell_cnt] == 'activated': activated_start[0][act_cnt] = pos[1][0].value_in_unit(angstroms) activated_start[1][act_cnt] = pos[1][1].value_in_unit(angstroms) act_cnt += 1 cell_cnt += 1 print(\"|------ calibration initiated -----|\") for num_iter in range(1, 2000): ### What is this? positions = simulation.context.getState(getPositions=True).getPositions() simulation.step(stepFreq) state = simulation.context.getState(getEnergy=True, getForces=True) time += stepFreq print(\"|----- simulation initiated -----|\") time_state = 1e-14 for num_iter in range(1, Repeat): ### What is this? positions = simulation.context.getState(getPositions=True).getPositions() # forces_vec will contain external forces that we want to feed into OpenMM. # Get current positions of the particles for concentration field/forces calculation ################################################################################################################## ### Where All the Magical Things Happen ### ################################################################################################################## if num_iter == 1: ConcByCell = np.zeros(num_particles) + 1e-14 fvX, fvY, fvZ, ConcbyCell = calc.calcForce(positions, num_particles, OriginOfExternalSignal, SourceOfOrigin, oriConc, cellConc, Diff, time_state, kd, highBC, DispScale, searchingRange, marker, auto_factor, DiffState, ConcByCell) #print(ConcbyCell[1]) stateVariable, stateDepFactor = calc.calcStateVariable(num_particles, time_state, ConcbyCell, stateVariable) if num_iter == 1: print('#********* The Beginning **********#') print(stateVariable[1],stateDepFactor[1]) elif num_iter == Repeat - 1: print('#********* The Ending **********#') print(stateVariable[1],stateDepFactor[1]) forces_vec = calc.calcForceModified(num_particles, fvX, fvY, fvZ, stateDepFactor, mig_factor) #print(forces_vec[1]) # Feed external forces into OpenMM in_force.updateForceInContext(simulation.context, forces_vec) # Advance simulation for 1 steps simulation.step(stepFreq) state = simulation.context.getState(getEnergy=True, getForces=True) time += stepFreq time_state += stepFreq #!/usr/bin/env python import sys import numpy as np ################################## # # Revisions # 10.08.10 inception # ################################## # # Message printed when program run without arguments # def helpmsg(): scriptName= sys.argv[0] msg=\"\"\" Purpose: Usage: \"\"\" msg+=\" -numOfCells [integer number]: a number of cells in the box \\n\" msg+=\" -lowlimBoxlen [integer number]: low boundary of simulation box in angstrom \\n\" msg+=\" -highlimBoxlen [integer number]: high boundary of simulation box in angstrom \\n\" msg+=\" -t [integer number]: a total step of simulation \\n\" msg+=\" -ds [integer number]: dumpting size \\n\" msg+=\" -name [fileName]: output file name \\n\" msg+=\" -input [fileName]: inputfile name- no need to change it \\n\" msg+=\" -CentoR [float]: radius of area where no microglia present \\n\" msg+=\" -oriConc [float]: max concentration of substance from origin \\n\" msg+=\" -cellConc [float]: max concentration of substance from cell \\n\" msg+=\" -Diff [float]:diffusion coefficient of substance \\n\" msg+=\" -kd [float]: \\n\" msg+=\" -DiffScale [float]: diffusion rate of cells \\n\" msg+=\" -searchingRange [float]: searching range in angstrom \\n\" msg+=\" -restingRatio [float]: ratio of resting cells to activated cells \\n\" msg+=\" -restMig [float]: resting cells migration rate factor \\n\" msg+=\" -actMig [float]: activated cells migration rate factor \\n\" msg+=\" -restAuto [float]: resting cells autocrine factor \\n\" msg+=\" -actAuto [float]: activated cells autocrine factor \\n\" msg+=\" -shape [string]: slap or square (default=None)\\n\" msg+=\" -DiffState [string]: steady or linear or erf (default=None) \\n\" msg+=\"\"\" Notes: \"\"\" return msg # # MAIN routine executed when launching this script from command line # if __name__ == \"__main__\": import sys msg = helpmsg() remap = \"none\" if len(sys.argv) &lt; 2: raise RuntimeError(msg) numOfCells1 = 50 numOfCells2 = 50 lowlimBoxlen = 0 # in angstrom highlimBoxlen =1000 # in angstrom SourceOfOrigin = None simLength = 10000 dumpSize = 10 CentoR = 0 pdbFileName = 'temp' dcdfilename = 'test_output' oriConc = 1 cellConc = 0.1 Diff = 20 kd = 0.1 DispScale = 100000 searchingRange = 0.1 restingRatio1 = 0.8 restingRatio2 = 0.8 restMig = 10 actMig = 1 restAuto = 5 actAuto = 0.1 shape = 'slap' DiffState = 'steady' for i,arg in enumerate(sys.argv): # calls 'runParams' with the next argument following the argument '-validation' if arg==\"-numOfCells1\": numOfCells1 = np.int(sys.argv[i+1]) if arg==\"-numOfCells2\": numOfCells2 = np.int(sys.argv[i+1]) if arg==\"-lowlimBoxlen\": lowlimBoxlen = np.int(sys.argv[i+1]) if arg==\"-highlimBoxlen\": highlimBoxlen = np.int(sys.argv[i+1]) if arg==\"-t\": simLength = np.int(sys.argv[i+1]) if arg==\"-ds\": dumpsize = np.int(sys.argv[i+1]) if arg==\"-name\": dcdfilename = sys.argv[i+1] if arg==\"-input\": pdbFileName = sys.argv[i+1] if arg==\"-oriConc\": oriConc = np.float(sys.argv[i+1]) if arg==\"-cellConc\": cellConc = np.float(sys.argv[i+1]) if arg==\"-Diff\": Diff = np.float(sys.argv[i+1]) if arg==\"-kd\": kd = np.float(sys.argv[i+1]) if arg=='-DispScale': DispScale = np.float(sys.argv[i+1]) if arg==\"-searchingRange\": searchingRange = np.float(sys.argv[i+1]) if arg==\"-restingRatio1\": restingRatio1 = np.float(sys.argv[i+1]) if arg==\"-restingRatio2\": restingRatio2 = np.float(sys.argv[i+1]) if arg==\"-CentoR\": CentoR = np.float(sys.argv[i+1]) if arg==\"-restMig\": restMig = np.float(sys.argv[i+1]) if arg==\"-actMig\": actMig = np.float(sys.argv[i+1]) if arg==\"-restAuto\": restAuto = np.float(sys.argv[i+1]) if arg==\"-actAuto\": actAuto = np.float(sys.argv[i+1]) if arg==\"-shape\": shape = sys.argv[i+1] if arg==\"-DiffState\": DiffState = sys.argv[i+1] if arg==\"-SourceOfOrigin\": SourceOfOrigin = sys.argv[i+1] simulator(oriConc = oriConc, # diffusion rate of substance from the origin cellConc = cellConc, # diffusion rate of substance from the cell Diff = Diff, kd = kd, DispScale = DispScale, searchingRange = searchingRange, numOfCells1 = numOfCells1, numOfCells2 = numOfCells2, CentoR = CentoR, pdbFileName = pdbFileName, dcdfilename = dcdfilename, lowlimBoxlen = lowlimBoxlen, # in angstrom highlimBoxlen = highlimBoxlen, # in angstrom SourceOfOrigin = SourceOfOrigin, simLength = simLength, dumpSize = dumpSize, restingRatio1 = restingRatio1, restingRatio2 = restingRatio2, restMig = restMig, actMig = actMig, restAuto = restAuto, actAuto = actAuto, shape = shape, DiffState = DiffState ) . ",
    "url": "http://localhost:4000/pages/user_guides/PythonScript/runner.html",
    "relUrl": "/pages/user_guides/PythonScript/runner.html"
  }
}
